import fs from "node:fs";
import path from "node:path";
import readline from "node:readline";
import {
  Client,
  Collection,
  Events,
  GatewayIntentBits,
  ActivityType,
} from "discord.js";
import { DISCORD_BOT_TOKEN, COMMAND_PREFIX, CLI_TOOLS } from "./config.js";
import type { BotClient, PrefixCommand, CommandContext } from "./types.js";
import type { ISessionManager } from "./sessions/types.js";
import { ClaudeSessionManager } from "./sessions/claude.js";
import { SubprocessSessionManager } from "./sessions/subprocess.js";
import { setSession } from "./commands/ask.js";

// ── Static command imports (for .exe bundling) ──────────────────────
import askCommand from "./commands/ask.js";
import sessionCommand from "./commands/session.js";
import execCommand from "./commands/exec.js";
import statusCommand from "./commands/status.js";
import helpCommand from "./commands/help.js";
import myidCommand from "./commands/myid.js";

// ── Console readline helper ──────────────────────────────────────────

function ask(question: string): Promise<string> {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });
  return new Promise((resolve) =>
    rl.question(question, (a) => {
      rl.close();
      resolve(a.trim());
    }),
  );
}

// ── Startup interactive setup ────────────────────────────────────────

async function startupSetup(): Promise<{ cliName: string; workingDir: string }> {
  const tools = Object.entries(CLI_TOOLS);

  console.log();
  console.log("=".repeat(48));
  console.log("  AI CLI Gateway Bot");
  console.log("=".repeat(48));

  // 1) CLI tool selection
  console.log();
  console.log("  [1/2] Select AI CLI tool:");
  console.log();
  tools.forEach(([key, t], i) => {
    console.log(`    ${i + 1}) ${t.name}  (${key})`);
  });
  console.log();

  let cliName: string;
  while (true) {
    const raw = await ask(`  Enter number [1-${tools.length}] (default: 1): `);
    if (raw === "") {
      cliName = tools[0][0];
      break;
    }
    const n = parseInt(raw, 10);
    if (n >= 1 && n <= tools.length) {
      cliName = tools[n - 1][0];
      break;
    }
    console.log("  Invalid choice, try again.");
  }

  const toolName = CLI_TOOLS[cliName].name;
  console.log(`  -> ${toolName} selected!`);

  // 2) Working directory
  console.log();
  console.log("  [2/2] Enter working directory:");
  console.log(`        (The folder where ${toolName} will run)`);
  console.log();

  let cwd: string;
  while (true) {
    const raw = await ask(`  Path (default: ${process.cwd()}): `);
    cwd = raw || process.cwd();
    cwd = cwd.replace(/^["']|["']$/g, "");
    if (fs.existsSync(cwd) && fs.statSync(cwd).isDirectory()) break;
    console.log(`  '${cwd}' is not a valid directory. Try again.`);
  }

  cwd = path.resolve(cwd);
  console.log(`  -> Working directory: ${cwd}`);
  console.log();
  console.log("=".repeat(48));
  console.log(`  ${toolName}  @  ${cwd}`);
  console.log("=".repeat(48));
  console.log();

  ensureRulesMd(cliName, cwd);

  return { cliName, workingDir: cwd };
}

// ── Rules MD ─────────────────────────────────────────────────────────

const RULES_MARKER = "# [AIDevelop Bot Rules]";
const RULES_TEMPLATE = `\
# [AIDevelop Bot Rules]
# Auto-generated by AIDevelop bot — do not remove this section.

## Working Directory Restriction
- You MUST only read, write, and modify files within this project directory.
- Do NOT access or modify files outside of this folder.
- Shell commands must only operate within this directory.

## Allowed Actions
- File operations (read, write, edit, search) — within this folder only
- Shell commands — within this folder only
- Web search and web fetch — allowed
`;

function ensureRulesMd(cliName: string, cwd: string): void {
  const tool = CLI_TOOLS[cliName];
  const filename = tool.rulesFile;
  const mdPath = path.join(cwd, filename);

  if (fs.existsSync(mdPath)) {
    const content = fs.readFileSync(mdPath, "utf-8");
    if (content.includes(RULES_MARKER)) {
      console.log(`  [${filename}] Rules already present`);
      return;
    }
    fs.appendFileSync(mdPath, "\n\n" + RULES_TEMPLATE, "utf-8");
    console.log(`  [${filename}] Appended rules to ${mdPath}`);
  } else {
    fs.writeFileSync(mdPath, RULES_TEMPLATE, "utf-8");
    console.log(`  [${filename}] Created ${mdPath}`);
  }
}

// ── Load commands (static — compatible with .exe bundling) ──────────

const allCommands: PrefixCommand[] = [
  askCommand,
  sessionCommand,
  execCommand,
  statusCommand,
  helpCommand,
  myidCommand,
];

function loadCommands(client: BotClient): void {
  for (const cmd of allCommands) {
    if (!cmd?.name) continue;
    client.commands.set(cmd.name, cmd);
    if (cmd.aliases) {
      for (const alias of cmd.aliases) {
        client.aliases.set(alias, cmd.name);
      }
    }
    console.log(`  [cmd] Loaded: ${cmd.name}`);
  }
}

// ── Create session manager ───────────────────────────────────────────

function createSession(cliName: string, cwd: string): ISessionManager {
  const tool = CLI_TOOLS[cliName];
  if (tool.useAgentSdk) {
    return new ClaudeSessionManager(tool, cwd);
  }
  return new SubprocessSessionManager(cliName, tool, cwd);
}

// ── Main ─────────────────────────────────────────────────────────────

async function main(): Promise<void> {
  if (!DISCORD_BOT_TOKEN) {
    console.error("DISCORD_BOT_TOKEN is not set. Check your .env file.");
    process.exit(1);
  }

  const { cliName, workingDir } = await startupSetup();

  const client = new Client({
    intents: [
      GatewayIntentBits.Guilds,
      GatewayIntentBits.GuildMessages,
      GatewayIntentBits.MessageContent,
    ],
  }) as BotClient;

  client.commands = new Collection();
  client.aliases = new Collection();
  client.selectedCli = cliName;
  client.workingDir = workingDir;

  // Create session & share with ask command
  const session = createSession(cliName, workingDir);
  setSession(session);

  // Load commands
  loadCommands(client);

  // ── Events ──

  client.on(Events.ClientReady, () => {
    const tool = CLI_TOOLS[cliName];
    const folder = path.basename(workingDir);
    console.log(`  Logged in as ${client.user?.tag}`);
    console.log(`  Active CLI: ${tool.name}  |  CWD: ${workingDir}`);
    client.user?.setActivity(`${tool.name} @ ${folder}`, {
      type: ActivityType.Listening,
    });
  });

  client.on(Events.MessageCreate, async (message) => {
    if (message.author.bot) return;
    if (!message.content.startsWith(COMMAND_PREFIX)) return;

    const args = message.content.slice(COMMAND_PREFIX.length).trim().split(/\s+/);
    const cmdName = args.shift()?.toLowerCase();
    if (!cmdName) return;

    const cmd =
      client.commands.get(cmdName) ??
      client.commands.get(client.aliases.get(cmdName) ?? "");
    if (!cmd) return;

    const ctx: CommandContext = { message, args, client };

    try {
      await cmd.execute(ctx);
    } catch (err: any) {
      console.error(`[error] Command ${cmdName}:`, err);
      await message.reply(`An error occurred: \`${err.message ?? err}\``).catch(() => {});
    }
  });

  // Graceful shutdown
  const shutdown = async () => {
    console.log("\n  Shutting down...");
    await session.cleanup();
    client.destroy();
    process.exit(0);
  };
  process.on("SIGINT", shutdown);
  process.on("SIGTERM", shutdown);

  await client.login(DISCORD_BOT_TOKEN);
}

main().catch((err) => {
  console.error("Fatal error:", err);
  process.exit(1);
});
